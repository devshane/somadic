#!/usr/bin/env ruby
require 'optparse'
require 'somadic'
require 'curses'
require 'progress_bar'
require 'thread'

# Monkey-patches ProgressBar so that it displays periods instead of blank
# spaces.
class ProgressBar
  def render_bar
    return '' if bar_width < 2
    "[" +
      "#" * (ratio * (bar_width - 2)).ceil +
      "." * ((1-ratio) * (bar_width - 2)).floor +
      "]"
  end
end

# A curses display.
class Display
  include Curses

  attr_accessor :kp_queue

  def initialize
    curses_init
    @bar = ProgressBar.new(1, :bar)

    @kp_queue = Queue.new
    start_keypress_thread
  end

  # Refreshes the display.
  def refresh
    Somadic::Logger.debug('Display#refresh')
    Curses.clear
    Curses.refresh
  end

  # Updates the display.
  def update(channel = nil, songs = nil)
    @channel = channel if channel
    @songs = songs if songs

    return if @channel.nil? || @songs.nil?

    cur_song = @songs.first

    # times
    start_time = Time.at(cur_song[:started])
    duration = cur_song[:duration]
    if duration <= 0
      end_time = nil
      remain_secs = 0
      remains = duration < 0 ?
                '[ Updating ]' :
                "[ #{start_time.strftime('%H:%M:%S')} ]"
    else
      end_time = start_time + duration
      remain_secs = (end_time - Time.now).to_i
      remains = "[ #{format_secs((Time.now - start_time).to_i)} " \
                "/ #{format_secs(duration)} ]"
    end

    # current song
    channel_and_track = "[ #{clean_channel_name(@channel[:name])} ]" \
                        "[ #{cur_song[:track]}"

    up = cur_song[:votes][:up]
    down = cur_song[:votes][:down]
    votes = up + down != 0 ? "+#{up}/-#{down}" : ''

    space_len = Curses.cols - votes.length - channel_and_track.length - remains.length - 2
    spaces = space_len > 0 ? ' ' * space_len : ''

    line = "#{channel_and_track}#{spaces}#{votes} ]#{remains}"
    over = Curses.cols - line.length
    if over < 0
      channel_and_track = channel_and_track[0..over - 1]
      line = "#{channel_and_track}#{spaces}#{votes} ]#{remains}"
    end
    cwrite 0, 0, line

    # current song progress
    if duration <= 0
      @bar.max = @bar.count = 100
    else
      @bar.max = duration
      @bar.count = (Time.now - start_time).to_i
    end
    cwrite 1, 0, @bar.to_s

    # song history
    row = 2
    @songs[1..-1].each do |song|
      up = song[:votes][:up]
      down = song[:votes][:down]
      votes = up + down != 0 ? ": +#{up}/-#{down} :" : ''

      track = "#{song[:track]}"

      if song[:duration] == 0
        duration = Time.at(song[:started]).strftime('%H:%M:%S')
      else
        duration = format_secs(song[:duration])
      end

      space_len = Curses.cols - track.length - votes.length - duration.length - 5
      spaces = space_len > 0 ? ' ' * space_len : ''

      line = ": #{track}#{spaces}#{votes} #{duration} :"
      over = Curses.cols - line.length
      if over < 0
        track = track[0..over - 1]
        line = ": #{track}#{spaces}#{votes} #{duration} :"
      end
      cwrite row, 0, line
      row += 1
    end
    # TODO: this works around the dupe thing @startup, but it shouldn't be
    # necessary
    cwrite row, 0, ''
  end

  private

  def start_keypress_thread
    Thread.new do
      loop do
        ch = Curses.getch
        if ch
          Somadic::Logger.debug("start_keypress_thread: adding #{ch}")
          begin
            @kp_queue << ch
          rescue => e
            Somadic::Logger.error("start_keypress_thread: error pushing to queue: #{e}")
          end
        end
        sleep 0.2
      end
    end
  end

  # Curses init
  def curses_init
    Curses.noecho
    Curses.curs_set(0)
    Curses.init_screen
    Curses.timeout = 0
  end

  # Curses write
  def cwrite(row, col, message)
    Curses.setpos(row, col)
    Curses.clrtoeol
    Curses.addstr(message)
    Curses.refresh
  end

  # Cursor pos
  def cpos(row, col)
    Curses.setpos(row, col)
    Curses.refresh
  end

  # Formats `seconds` to hours, mins, secs.
  def format_secs(seconds)
    secs = seconds.abs
    hours = 0
    if secs > 3600
      hours = secs / 3600
      secs -= 3600 * hours
    end
    mins = secs / 60
    secs = secs % 60
    h = hours > 0 ? "#{"%d" % hours}:" : ""
    "#{h}#{"%02d" % mins}:#{"%02d" % secs}"
  end

  # Cleans up soma channel names.
  def clean_channel_name(name)
    cname = name.gsub(/130$/, '')
    cname.gsub!(/64$/, '')
    cname
  end
end

Signal.trap("INT") do |sig|
  @channel.stop
  exit
end

@display = Display.new
@options = { cache: nil,
             cache_min: nil,
             listeners: [@display] }

@optparser = OptionParser.new do |o|
  o.banner = 'Usage: somadic [options] site:channel [site:channel]'
  o.separator ''
  o.separator 'The `site` parameter can be di or soma. `channel` should be'
  o.separator 'a valid channel on that site.'
  o.separator ''
  o.separator 'DI premium channels require an environment variable: ' \
              'DI_FM_PREMIUM_ID.'
  o.separator ''

  o.on('-c CACHE_SIZE', '--cache CACHE_SIZE', 'Set the cache size (KB)') do |c|
    @options[:cache] = c
  end
  o.on('-m CACHE_MIN', '--cache-min CACHE_MIN',
       'Set the minimum cache threshold (percent)') do |m|
    @options[:cache_min] = m
  end
  o.on('-h', '--help', 'Display this message') { puts o; exit }

  o.parse!
end

def usage
  puts @optparser
  puts
  exit
end

def next_channel
  @cur_chan ||= 0

  rv = @channels[@cur_chan]
  @cur_chan += 1
  @cur_chan = 0 if @cur_chan == @channels.count
  rv
end

def start_playing
  who, what = next_channel.split(':')
  @options[:channel] = what
  if who == 'di'
    @options[:premium_id] = ENV['DI_FM_PREMIUM_ID']
    @channel = Somadic::Channel::DI.new(@options)
  else
    @channel = Somadic::Channel::Soma.new(@options)
  end
  @channel.start
end

def start(channels)
  Somadic::Logger.debug("somadic-curses, started with #{channels}")

  @channels = channels
  start_playing

  # keypresses are handled thru a Queue
  keypresses = []
  quitting = false
  while !quitting
    begin
      keypresses << @display.kp_queue.pop(non_block: true)
    rescue ThreadError => te
      unless te.to_s == "queue empty"
        Somadic::Logger.error("kp_queue.pop error: #{te}")
      end
    end
    unless keypresses.empty?
      keypresses.each do |kp|
        Somadic::Logger.debug("processing keypress: #{kp}")
        case kp
        when 'c'
          @channel.channels.each do |c|
            Somadic::Logger.debug("channel: #{c}")
          end
        when 'n'
          @channel.stop
          who, what = next_channel.split(':')
          Somadic::Logger.debug("going to next channel #{who} - #{what}")
          @options[:channel] = what
          if who == 'di'
            @channel = Somadic::Channel::DI.new(@options)
          else
            @channel = Somadic::Channel::Soma.new(@options)
          end
          @channel.start
        when 'N'
          @channel.stop
          who = @channel.is_a?(Somadic::Channel::DI) ? 'di' : 'soma'
          name = @channel.channels.sample[:name]
          Somadic::Logger.debug("going to random next channel #{who} - #{name}")
          @options[:channel] = name
          if who == 'di'
            @channel = Somadic::Channel::DI.new(@options)
          else
            @channel = Somadic::Channel::Soma.new(@options)
          end
          @channel.start
        when 'q'
          @channel.stop
          quitting = true
        when 'r'
          @display.refresh
        end
        keypresses.delete(kp)
      end
    end

    @display.update
    sleep 0.2
  end
end

usage if ARGV[0].nil?
start(ARGV)
